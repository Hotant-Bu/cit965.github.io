---
sidebar_label: 43.wait
sidebar_position: 11
title: 43.wait
---


### PR #943
> Clients must wait for completion of actions

```go
// podsOnMinions returns true when all of the selected pods exist on a minion.
func podsOnMinions(c *client.Client, pods api.PodList) wait.ConditionFunc {
	podInfo := fakePodInfoGetter{}
	return func() (bool, error) {
		for i := range pods.Items {
			host, id := pods.Items[i].CurrentState.Host, pods.Items[i].ID
			if len(host) == 0 {
				return false, nil
			}
			if _, err := podInfo.GetPodInfo(host, id); err != nil {
				return false, nil
			}
		}
		return true, nil
	}
}

	// wait for minions to indicate they have info about the desired pods
	pods, err := c.ListPods(labels.Set(controllerRequest.DesiredState.ReplicaSelector).AsSelector())
	if err != nil {
		glog.Fatalf("FAILED: unable to get pods to list: %v", err)
	}
	if err := wait.Poll(time.Second, 10, podsOnMinions(c, pods)); err != nil {
		glog.Fatalf("FAILED: pods never started running %v", err)
	}
```	

### PR #909
> Scheduler plugin v1

```go
func main() {
	flag.Parse()
	util.InitLogs()
	defer util.FlushLogs()

	verflag.PrintAndExitIfRequested()

	// TODO: security story for plugins!
	kubeClient := client.New("http://"+*master, nil)

	configFactory := &factory.ConfigFactory{Client: kubeClient}
	config := configFactory.Create()
	s := scheduler.New(config)
	s.Run()

	select {}
}

// Run begins watching and scheduling. It starts a goroutine and returns immediately.
func (s *Scheduler) Run() {
	go util.Forever(s.scheduleOne, 0)
}

func (s *Scheduler) scheduleOne() {
	pod := s.config.NextPod()
	dest, err := s.config.Algorithm.Schedule(*pod, s.config.MinionLister)
	if err != nil {
		s.config.Error(pod, err)
		return
	}
	b := &api.Binding{
		PodID: pod.ID,
		Host:  dest,
	}
	if err := s.config.Binder.Bind(b); err != nil {
		s.config.Error(pod, err)
	}
}
```

main：主函数首先解析命令行参数，然后初始化日志系统。之后，它创建一个 Kubernetes 客户端 kubeClient，该客户端用于与 Kubernetes API 服务器交互。然后，主函数创建一个配置工厂 configFactory 并用该工厂创建一个调度器配置 config。最后，主函数创建并运行一个调度器，然后挂起（由于 select {}，程序会阻塞在这里，不会立即结束，因为调度器在后台运行）。

Run：此方法在新的 goroutine 中启动调度器，使用 util.Forever(s.scheduleOne, 0) 循环执行 scheduleOne 方法，实现对 Pod 的持续调度。

scheduleOne：此方法处理单个 Pod 的调度。它首先从配置中获取下一个待调度的 Pod，然后使用调度算法为这个 Pod 选择一个 Node（节点）。如果调度成功，就创建一个 Binding 对象并尝试进行绑定操作。如果绑定操作或者调度算法返回错误，就使用 s.config.Error(pod, err) 方法处理错误。

