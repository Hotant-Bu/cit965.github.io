---
sidebar_label: '02'
sidebar_position: 3
title: http 源码解读
---

```go
func ListenAndServe(addr string, handler Handler) error {
	server := &Server{Addr: addr, Handler: handler}
	return server.ListenAndServe()
}
func (srv *Server) ListenAndServe() error {
	addr := srv.Addr
	// 创建网络监听器：ln, err := net.Listen("tcp", addr)这行代码尝试使用 "tcp" 协议在指定的地址（addr）上创建一个网络监听器（ln）。如果出现错误（如地址已被占用），则将错误赋值给 err。
	ln, err := net.Listen("tcp", addr)
	if err != nil {
		return err
	}
	return srv.Serve(ln)
}
```

我们主要来看 srv 上的Serve 方法
```go
func (srv *Server) Serve(l net.Listener) error {
	if fn := testHookServerServe; fn != nil {
		fn(srv, l) // call hook with unwrapped listener
	}

	origListener := l
	l = &onceCloseListener{Listener: l}
	defer l.Close()

	if err := srv.setupHTTP2_Serve(); err != nil {
		return err
	}

	if !srv.trackListener(&l, true) {
		return ErrServerClosed
	}
	defer srv.trackListener(&l, false)

	baseCtx := context.Background()
	if srv.BaseContext != nil {
		baseCtx = srv.BaseContext(origListener)
		if baseCtx == nil {
			panic("BaseContext returned a nil context")
		}
	}

	var tempDelay time.Duration // how long to sleep on accept failure

	ctx := context.WithValue(baseCtx, ServerContextKey, srv)
	for {
		rw, err := l.Accept()
		if err != nil {
			if srv.shuttingDown() {
				return ErrServerClosed
			}
			if ne, ok := err.(net.Error); ok && ne.Temporary() {
				if tempDelay == 0 {
					tempDelay = 5 * time.Millisecond
				} else {
					tempDelay *= 2
				}
				if max := 1 * time.Second; tempDelay > max {
					tempDelay = max
				}
				srv.logf("http: Accept error: %v; retrying in %v", err, tempDelay)
				time.Sleep(tempDelay)
				continue
			}
			return err
		}
		connCtx := ctx
		if cc := srv.ConnContext; cc != nil {
			connCtx = cc(connCtx, rw)
			if connCtx == nil {
				panic("ConnContext returned nil")
			}
		}
		tempDelay = 0
		c := srv.newConn(rw)
		c.setState(c.rwc, StateNew, runHooks) // before Serve can return
		go c.serve(connCtx)
	}
}
```

这是用 Go 语言编写的代码，是 http.Server 结构体的一个方法，用于接受传入的连接并启动新的协程来处理这些连接。这个方法的主要任务是监听连接请求，处理连接错误，并为每个连接创建一个新的协程。以下是代码的详细解释：

定义 Serve 方法：func (srv *Server) Serve(l net.Listener) error
Serve 方法属于 Server 结构体，接收一个网络监听器 l 作为参数，并返回一个错误。

检查是否有测试钩子函数：if fn := testHookServerServe; fn != nil
如果存在测试钩子函数，将调用它。这通常用于测试目的。

创建一个只能关闭一次的监听器：l = &onceCloseListener{Listener: l}
使用 onceCloseListener 结构体包装原始监听器，确保只关闭一次。

关闭监听器：defer l.Close()
在函数执行结束时关闭监听器。

设置 HTTP/2 支持：if err := srv.setupHTTP2_Serve(); err != nil
如果在设置 HTTP/2 时发生错误，返回错误。

跟踪监听器：if !srv.trackListener(&l, true)
如果无法跟踪监听器，返回预定义错误 ErrServerClosed。

设置基本上下文：baseCtx := context.Background()
创建一个基本的上下文对象，后续会为每个连接创建一个上下文。

循环监听并处理连接：

使用 l.Accept() 接受新的连接请求。
如果发生错误，检查是否是因为服务器正在关闭，或者是否是暂时性错误。
如果是暂时性错误，增加延迟时间并重试，直到延迟时间达到1秒。
对于每个成功的连接，为其创建一个新的协程并调用 c.serve(connCtx) 来处理请求。


设置上下文：ctx := context.WithValue(baseCtx, ServerContextKey, srv)
在每次循环中，都会将 Server 结构体作为上下文值存储在 ctx 中。这允许在处理连接请求时访问服务器实例。

为每个连接创建上下文：connCtx := ctx
通过使用当前的上下文作为基础，为每个接受的连接创建一个新的上下文。

自定义连接上下文：if cc := srv.ConnContext; cc != nil
如果服务器实例提供了 ConnContext 函数，则使用它自定义连接上下文。

初始化连接：c := srv.newConn(rw)
为接受的连接创建一个新的 conn 实例。这个实例将负责处理与客户端的通信。

设置连接状态：c.setState(c.rwc, StateNew, runHooks)
设置新连接的状态为 StateNew，并运行相关的钩子函数。这些钩子函数通常用于连接状态变化时的回调。

在新的协程中处理连接：go c.serve(connCtx)
为每个接受的连接创建一个新的协程，处理客户端的请求。这使得服务器能够并发地处理多个连接。


这段代码实现了一个 HTTP 服务器的核心功能。它创建了一个网络监听器，监听传入的连接请求。对于每个接受的连接，它都会创建一个新的协程来处理客户端的请求。通过使用上下文，服务器能够管理与连接相关的状态和数据。这使得服务器能够并发地处理多个连接，提高了性能和响应速度。

```go
// Serve a new connection.
func (c *conn) serve(ctx context.Context) {
	c.remoteAddr = c.rwc.RemoteAddr().String()
	ctx = context.WithValue(ctx, LocalAddrContextKey, c.rwc.LocalAddr())
	var inFlightResponse *response
	defer func() {
		if err := recover(); err != nil && err != ErrAbortHandler {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			c.server.logf("http: panic serving %v: %v\n%s", c.remoteAddr, err, buf)
		}
		if inFlightResponse != nil {
			inFlightResponse.cancelCtx()
		}
		if !c.hijacked() {
			if inFlightResponse != nil {
				inFlightResponse.conn.r.abortPendingRead()
				inFlightResponse.reqBody.Close()
			}
			c.close()
			c.setState(c.rwc, StateClosed, runHooks)
		}
	}()

	if tlsConn, ok := c.rwc.(*tls.Conn); ok {
		tlsTO := c.server.tlsHandshakeTimeout()
		if tlsTO > 0 {
			dl := time.Now().Add(tlsTO)
			c.rwc.SetReadDeadline(dl)
			c.rwc.SetWriteDeadline(dl)
		}
		if err := tlsConn.HandshakeContext(ctx); err != nil {
			// If the handshake failed due to the client not speaking
			// TLS, assume they're speaking plaintext HTTP and write a
			// 400 response on the TLS conn's underlying net.Conn.
			if re, ok := err.(tls.RecordHeaderError); ok && re.Conn != nil && tlsRecordHeaderLooksLikeHTTP(re.RecordHeader) {
				io.WriteString(re.Conn, "HTTP/1.0 400 Bad Request\r\n\r\nClient sent an HTTP request to an HTTPS server.\n")
				re.Conn.Close()
				return
			}
			c.server.logf("http: TLS handshake error from %s: %v", c.rwc.RemoteAddr(), err)
			return
		}
		// Restore Conn-level deadlines.
		if tlsTO > 0 {
			c.rwc.SetReadDeadline(time.Time{})
			c.rwc.SetWriteDeadline(time.Time{})
		}
		c.tlsState = new(tls.ConnectionState)
		*c.tlsState = tlsConn.ConnectionState()
		if proto := c.tlsState.NegotiatedProtocol; validNextProto(proto) {
			if fn := c.server.TLSNextProto[proto]; fn != nil {
				h := initALPNRequest{ctx, tlsConn, serverHandler{c.server}}
				// Mark freshly created HTTP/2 as active and prevent any server state hooks
				// from being run on these connections. This prevents closeIdleConns from
				// closing such connections. See issue https://golang.org/issue/39776.
				c.setState(c.rwc, StateActive, skipHooks)
				fn(c.server, tlsConn, h)
			}
			return
		}
	}

	// HTTP/1.x from here on.

	ctx, cancelCtx := context.WithCancel(ctx)
	c.cancelCtx = cancelCtx
	defer cancelCtx()

	c.r = &connReader{conn: c}
	c.bufr = newBufioReader(c.r)
	c.bufw = newBufioWriterSize(checkConnErrorWriter{c}, 4<<10)

	for {
		w, err := c.readRequest(ctx)
		if c.r.remain != c.server.initialReadLimitSize() {
			// If we read any bytes off the wire, we're active.
			c.setState(c.rwc, StateActive, runHooks)
		}
		if err != nil {
			const errorHeaders = "\r\nContent-Type: text/plain; charset=utf-8\r\nConnection: close\r\n\r\n"

			switch {
			case err == errTooLarge:
				// Their HTTP client may or may not be
				// able to read this if we're
				// responding to them and hanging up
				// while they're still writing their
				// request. Undefined behavior.
				const publicErr = "431 Request Header Fields Too Large"
				fmt.Fprintf(c.rwc, "HTTP/1.1 "+publicErr+errorHeaders+publicErr)
				c.closeWriteAndWait()
				return

			case isUnsupportedTEError(err):
				// Respond as per RFC 7230 Section 3.3.1 which says,
				//      A server that receives a request message with a
				//      transfer coding it does not understand SHOULD
				//      respond with 501 (Unimplemented).
				code := StatusNotImplemented

				// We purposefully aren't echoing back the transfer-encoding's value,
				// so as to mitigate the risk of cross side scripting by an attacker.
				fmt.Fprintf(c.rwc, "HTTP/1.1 %d %s%sUnsupported transfer encoding", code, StatusText(code), errorHeaders)
				return

			case isCommonNetReadError(err):
				return // don't reply

			default:
				if v, ok := err.(statusError); ok {
					fmt.Fprintf(c.rwc, "HTTP/1.1 %d %s: %s%s%d %s: %s", v.code, StatusText(v.code), v.text, errorHeaders, v.code, StatusText(v.code), v.text)
					return
				}
				publicErr := "400 Bad Request"
				fmt.Fprintf(c.rwc, "HTTP/1.1 "+publicErr+errorHeaders+publicErr)
				return
			}
		}

		// Expect 100 Continue support
		req := w.req
		if req.expectsContinue() {
			if req.ProtoAtLeast(1, 1) && req.ContentLength != 0 {
				// Wrap the Body reader with one that replies on the connection
				req.Body = &expectContinueReader{readCloser: req.Body, resp: w}
				w.canWriteContinue.Store(true)
			}
		} else if req.Header.get("Expect") != "" {
			w.sendExpectationFailed()
			return
		}

		c.curReq.Store(w)

		if requestBodyRemains(req.Body) {
			registerOnHitEOF(req.Body, w.conn.r.startBackgroundRead)
		} else {
			w.conn.r.startBackgroundRead()
		}

		// HTTP cannot have multiple simultaneous active requests.[*]
		// Until the server replies to this request, it can't read another,
		// so we might as well run the handler in this goroutine.
		// [*] Not strictly true: HTTP pipelining. We could let them all process
		// in parallel even if their responses need to be serialized.
		// But we're not going to implement HTTP pipelining because it
		// was never deployed in the wild and the answer is HTTP/2.
		inFlightResponse = w
		serverHandler{c.server}.ServeHTTP(w, w.req)
		inFlightResponse = nil
		w.cancelCtx()
		if c.hijacked() {
			return
		}
		w.finishRequest()
		c.rwc.SetWriteDeadline(time.Time{})
		if !w.shouldReuseConnection() {
			if w.requestBodyLimitHit || w.closedRequestBodyEarly() {
				c.closeWriteAndWait()
			}
			return
		}
		c.setState(c.rwc, StateIdle, runHooks)
		c.curReq.Store(nil)

		if !w.conn.server.doKeepAlives() {
			// We're in shutdown mode. We might've replied
			// to the user without "Connection: close" and
			// they might think they can send another
			// request, but such is life with HTTP/1.1.
			return
		}

		if d := c.server.idleTimeout(); d != 0 {
			c.rwc.SetReadDeadline(time.Now().Add(d))
		} else {
			c.rwc.SetReadDeadline(time.Time{})
		}

		// Wait for the connection to become readable again before trying to
		// read the next request. This prevents a ReadHeaderTimeout or
		// ReadTimeout from starting until the first bytes of the next request
		// have been received.
		if _, err := c.bufr.Peek(4); err != nil {
			return
		}

		c.rwc.SetReadDeadline(time.Time{})
	}
```

这段代码定义了一个名为 serve 的方法，它是 conn 类型的方法。conn 类型代表一个客户端到服务器的连接。serve 方法负责处理与客户端的通信，包括解析 HTTP 请求、调用请求处理器并发送 HTTP 响应。让我们逐步分析这段代码：

设置远程地址：c.remoteAddr = c.rwc.RemoteAddr().String() 将远程客户端的地址存储在 c.remoteAddr 中。

添加本地地址到上下文：ctx = context.WithValue(ctx, LocalAddrContextKey, c.rwc.LocalAddr()) 将连接的本地地址添加到上下文中。

使用 defer 语句处理连接结束时的清理工作。

对于 TLS 连接（即 HTTPS），执行 TLS 握手。如果失败，则处理错误并返回。

如果成功建立了 TLS 连接，检查是否已协商了有效的下一个协议（例如 HTTP/2）。如果是，则执行对应的处理函数并返回。

从这里开始，代码处理 HTTP/1.x 连接。

为每个请求创建一个带有取消功能的上下文。这可以让请求处理器在连接关闭或超时时取消阻塞操作。

为连接设置读取器和写入器缓冲区，以提高性能。

当读取并解析请求时，serve 方法会检查错误并相应地发送错误响应。例如：
a. 如果请求头过大（errTooLarge），发送 431 状态码（Request Header Fields Too Large）。
b. 如果遇到不支持的传输编码（isUnsupportedTEError(err)），发送 501 状态码（Not Implemented）。
c. 如果是常见的网络读取错误（isCommonNetReadError(err)），则不发送响应，直接返回。
d. 其他情况下，发送 400 状态码（Bad Request）。

当请求处理器处理完请求后，serve 方法会执行以下操作：
a. 取消请求上下文。
b. 检查连接是否已被劫持（c.hijacked()）。如果是，则返回。
c. 完成请求处理，例如关闭响应主体（w.finishRequest()）。
d. 设置连接的写入截止时间为零，以便之后复用。

在处理请求之间，serve 方法会检查连接是否可以复用（w.shouldReuseConnection()）。如果不能复用（例如，由于错误或客户端/服务器关闭连接），则关闭连接并返回。

如果服务器配置为不进行长连接（!w.conn.server.doKeepAlives()），则在处理完请求后返回，而不再等待下一个请求。

当等待下一个请求时，serve 方法会设置连接的空闲超时（如果有的话），并等待连接变为可读。这样可以确保只有在收到下一个请求的第一个字节时，才开始读取超时。


### 关键点

这上面的代码中，我们需要注意的是

**serverHandler{c.server}.ServeHTTP(w, w.req)** 这段代码是 go 官方库 留给我们写自定义http框架的暴露点，如果handler ！= nil 就会使用我们自己的handler


```go

func (sh serverHandler) ServeHTTP(rw ResponseWriter, req *Request) {
	handler := sh.srv.Handler
	if handler == nil {
		handler = DefaultServeMux
	}
	if !sh.srv.DisableGeneralOptionsHandler && req.RequestURI == "*" && req.Method == "OPTIONS" {
		handler = globalOptionsHandler{}
	}

	if req.URL != nil && strings.Contains(req.URL.RawQuery, ";") {
		var allowQuerySemicolonsInUse atomic.Bool
		req = req.WithContext(context.WithValue(req.Context(), silenceSemWarnContextKey, func() {
			allowQuerySemicolonsInUse.Store(true)
		}))
		defer func() {
			if !allowQuerySemicolonsInUse.Load() {
				sh.srv.logf("http: URL query contains semicolon, which is no longer a supported separator; parts of the query may be stripped when parsed; see golang.org/issue/25192")
			}
		}()
	}

	handler.ServeHTTP(rw, req)
}
```

这段代码定义了一个名为 ServeHTTP 的方法，它属于 serverHandler 结构体。ServeHTTP 方法接受两个参数：一个 ResponseWriter 接口类型的参数 rw 和一个指向 Request 结构体的指针类型参数 req。ResponseWriter 接口允许向客户端发送 HTTP 响应，Request 结构体包含客户端发送的 HTTP 请求的详细信息。

在这个方法中，首先检查 sh.srv.Handler 是否为 nil。Handler 是一个接口类型，用于处理 HTTP 请求。如果 Handler 为 nil，则将默认的处理器 DefaultServeMux 分配给 handler 变量。

接下来，检查是否需要使用 globalOptionsHandler 替换当前的处理器。这在请求方法为 "OPTIONS" 且请求 URI 为 "*" 时会发生。这是一个通用的 OPTIONS 请求处理器，可以处理对服务器根目录的 OPTIONS 请求。

接着，检查请求 URL 中的 RawQuery 是否包含分号（";"）。由于分号在 URL 查询参数中的作用已经被弃用，所以在这里发出警告。将一个 func 添加到请求的上下文中，当请求处理器访问该 func 时，警告将被禁止。

最后，调用 handler.ServeHTTP(rw, req) 来处理请求。这将调用相应的请求处理器（如 DefaultServeMux 或自定义处理器），对客户端发出的 HTTP 请求进行处理，并生成适当的 HTTP 响应。