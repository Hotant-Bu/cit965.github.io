---
sidebar_label: '01'
sidebar_position: 2
title: 启动一个http服务
---

## 启动一个最简单的http服务
```go
package main

import (
	"net/http"
)

func main() {
	http.ListenAndServe(":8888", http.HandlerFunc(SelfFunc))
}

func SelfFunc(res http.ResponseWriter, req *http.Request) {
	res.WriteHeader(200)
	res.Write([]byte("success"))
}


```

当运行这个程序时，它将启动一个 HTTP 服务器，监听在端口 8888。当有 HTTP 请求到达时，它会调用 SelfFunc SelfFunc 函数会设置响应状态码为 200，并向客户端返回 "success" 字符串。

这里我们主要看一下  http.ListenAndServer 这个函数签名：

```go
// ListenAndServe listens on the TCP network address addr and then calls
// Serve with handler to handle requests on incoming connections.
// 这两行注释说明 ListenAndServe 函数监听 TCP 网络地址（addr 参数），然后使用 handler 参数处理传入的连接上的请求。

// Accepted connections are configured to enable TCP keep-alives.
//这一行注释说明已接受的连接会被配置为启用 TCP keep-alives（保持连接活跃的心跳机制）


// The handler is typically nil, in which case the DefaultServeMux is used.
//这一行注释说明 handler 参数通常为 nil，在这种情况下，将使用 DefaultServeMux 作为默认处理器

// ListenAndServe always returns a non-nil error.
// 这一行注释说明 ListenAndServe 函数总是返回一个非 nil 的错误。
func ListenAndServe(addr string, handler Handler) error {
	server := &Server{Addr: addr, Handler: handler}
	return server.ListenAndServe()
}
```

我们看一下 Handler 是什么东西
```go
// A Handler responds to an HTTP request.
//这一行注释说明 Handler 是一个处理 HTTP 请求的接口


// ServeHTTP should write reply headers and data to the ResponseWriter
// and then return. Returning signals that the request is finished; it
// is not valid to use the ResponseWriter or read from the
// Request.Body after or concurrently with the completion of the
// ServeHTTP call.
//这几行注释指出，ServeHTTP 方法应该将响应头和数据写入 ResponseWriter，然后返回。返回表示请求已经处理完毕。在 ServeHTTP 调用完成之后或与其同时，不应再使用 ResponseWriter 或从 Request.Body 中读取数据。


// Depending on the HTTP client software, HTTP protocol version, and
// any intermediaries between the client and the Go server, it may not
// be possible to read from the Request.Body after writing to the
// ResponseWriter. Cautious handlers should read the Request.Body
// first, and then reply.
//这几行注释提醒，根据 HTTP 客户端软件、HTTP 协议版本和客户端与 Go 服务器之间的任何中间代理的不同，可能在写入 ResponseWriter 之后无法再从 Request.Body 中读取数据。谨慎的处理程序应先读取 Request.Body，然后再进行响应。


// Except for reading the body, handlers should not modify the
// provided Request.
//这一行注释说明，处理程序除了读取请求体之外，不应修改提供的 Request


// If ServeHTTP panics, the server (the caller of ServeHTTP) assumes
// that the effect of the panic was isolated to the active request.
// It recovers the panic, logs a stack trace to the server error log,
// and either closes the network connection or sends an HTTP/2
// RST_STREAM, depending on the HTTP protocol. To abort a handler so
// the client sees an interrupted response but the server doesn't log
// an error, panic with the value ErrAbortHandler.
// 这几行注释描述了当 ServeHTTP 发生 panic（运行时错误）时的处理方式。服务器（ServeHTTP 的调用者）会假定 panic 的影响仅限于当前活跃的请求。服务器会恢复 panic，将堆栈跟踪记录到服务器错误日志，并根据 HTTP 协议关闭网络连接或发送 HTTP/2 的 RST_STREAM（复位流）。要终止处理程序以便客户端看到中断的响应但服务器不记录错误，可以使用 ErrAbortHandler 值进行 panic。
type Handler interface {
	ServeHTTP(ResponseWriter, *Request)
}
```

Handler 接口定义了一个方法：ServeHTTP，它接受两个参数，一个 ResponseWriter 类型，用于处理 HTTP 响应；一个指向 Request 类型,在上面的代码示例中，我们使用了适配器模式,  http.HandlerFun 可以让我们的函数 SelfFunc 变成一个 实现了 handler 接口的函数

```go
// The HandlerFunc type is an adapter to allow the use of
// ordinary functions as HTTP handlers. If f is a function
// with the appropriate signature, HandlerFunc(f) is a
// Handler that calls f.
// 这几行注释说明 HandlerFunc 类型是一个适配器，用于将普通函数作为 HTTP 处理器。如果 f 是具有适当签名的函数，则 HandlerFunc(f) 是一个调用 f 的处理器（实现了 Handler 接口）。
type HandlerFunc func(ResponseWriter, *Request)

// ServeHTTP calls f(w, r).
func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {
	f(w, r)
}
```

例如，一开始提到的代码 http.ListenAndServe(":8888", http.HandlerFunc(SelfFunc))，这里将 SelfFunc 函数转换为 HandlerFunc 类型，从而实现了 Handler 接口，可以作为处理器传递给 ListenAndServe 函数。